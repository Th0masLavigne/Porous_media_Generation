# Created by Thomas Lavigne
# 22/03/2023
# 
def print_info_versions():
	print("""The version of Neper used is:
		
========================	N   e   p   e   r	=======================
Info   : A software package for polycrystal generation and meshing.
Info   : Version 4.5.1-4
Info   : Built with: gsl|muparser|opengjk|openmp|nlopt|libscotch (full)
Info   : Running on 8 threads.
Info   : <https://neper.info>
Info   : Copyright (C) 2003-2022, and GNU GPL'd, by Romain Quey.
========================================================================

The python3 environment is used. Pymesh can be run within a docker environment:

docker run -ti -v $(pwd):/home/pymesh/shared -w /home/pymesh/shared pymesh/pymesh bash
	""")
	pass
# 
def read_tess_file(filename):
	"""
	Reads a `.tess` file generated by Neper and extracts vertices and edges into NumPy arrays. 
	The function parses the file to determine the number of cells from the filename and extracts 
	the corresponding vertices and edges.

	Parameters:
	- filename (str): The path to the `.tess` file. The filename should contain an integer that 
	  represents the number of cells. This number is extracted from the filename itself (e.g., 
	  `mesh_1000.tess` would extract `1000` as the number of cells).
	
	Returns:
	- vertices (np.ndarray): A 2D numpy array of shape (N_vertices, 3), where each row contains 
	  the (x, y, z) coordinates of a vertex. These coordinates are assumed to be in units of meters.
	- edges (np.ndarray): A 2D numpy array of shape (N_edges, 2), where each row represents an 
	  edge by referencing the indices (0-based) of the two vertices that form the edge.
	- number_of_cells (int): The number of cells extracted from the filename. The value is parsed 
	  from the filename itself, assuming the filename contains an integer value representing the 
	  number of cells.

	Raises:
	- ValueError: If the filename does not contain a valid number for the cells or if the `.tess` 
	  file structure is not as expected.

	Notes:
	- The `.tess` file format is assumed to have the following structure:
	  - The first 9 lines contain general information.
	  - The next lines contain `number_of_cells` seeds and orientations.
	  - The vertex data starts after a header and includes the number of vertices followed by the vertex coordinates.
	  - The edge data starts after a header and includes the number of edges followed by pairs of vertex indices forming each edge.
	- The function assumes that the vertex data is in 3D coordinates and that the indices in the edge data are 1-based, 
	  which are converted to 0-based indexing.

	Example:
	```
	vertices, edges, number_of_cells = read_tess_file('mesh_1000.tess')
	```

	This function is designed to work with `.tess` files generated by Neper's tessellation tool.
	"""
	# Import libraries
	import numpy
	import re
	# Extract from the file name the number of cells.
	regex = re.compile(r'\d+')
	regex.findall(filename)
	if not regex:
		raise ValueError("Filename does not contain a valid cell number.")
	# 
	list_numbers_in_filename=[int(x) for x in regex.findall(filename)]
	number_of_cells = list_numbers_in_filename[0]
	# .tess reading and extraction
	# 9 first lines are general info, number_of_cells+1 next are seeds, number_of_cells+2 next are ori, 
	# then 1 line header for vertices, 1 line number of vertices, number_of_vertices lines
	# then 1 line header for edges, 1 line number of edges, number_of_edges lines
	with open(filename, 'r') as f:
		content = f.readlines()
		# Determine positions of relevant data in the file
		number_of_vertices = int(content[13+2*number_of_cells])
		number_of_edges = int(content[15+2*number_of_cells+number_of_vertices])
		# Initialize arrays
		vertices = numpy.zeros((number_of_vertices,3))
		edges = numpy.zeros((number_of_edges,2), dtype=int)
		ii=0
		# Read vertex data
		for x in content[13+2*number_of_cells+1:13+2*number_of_cells+number_of_vertices+1]:
			row = x.split()
			vertices[ii]=[float(row[1]),float(row[2]),float(row[3])]
			ii+=1
		jj=0
		# Read edge data
		for x in content[15+2*number_of_cells+number_of_vertices+1:15+2*number_of_cells+number_of_vertices+number_of_edges+1]:
			row = x.split()
			edges[jj]=[int(row[1])-1,int(row[2])-1]
			jj+=1
	return vertices, edges, number_of_cells
# 
def read_tess_file_mm_to_m(filename):
	"""
	Reads a `.tess` file generated by Neper and extracts the vertices and edges into numpy arrays. 
	The function also determines the number of cells from the file name and extracts the corresponding 
	data from the file.

	Parameters:
	- filename (str): The path to the `.tess` file. The filename should include the number of cells 
	  (an integer), which will be extracted automatically.

	Returns:
	- vertices (np.ndarray): A 2D numpy array of shape (N_vertices, 3) containing the 3D coordinates 
	  of each vertex. The coordinates are scaled by a factor of 1e-3 (assuming the data is in millimeters).
	- edges (np.ndarray): A 2D numpy array of shape (N_edges, 2) representing the edges. Each row contains 
	  the indices of the two vertices (0-indexed) that form the edge.
	- number_of_cells (int): The number of cells extracted from the filename. This value is inferred 
	  from the number found in the filename (e.g., `mesh_1000.tess` will extract `1000`).

	Notes:
	- The `.tess` file format is expected to have specific line structures. The first 9 lines contain general 
	  information, followed by a sequence of lines dedicated to seeds, orientations, vertices, and edges.
	- The function assumes that the file contains a header for vertices and edges, with the number of vertices 
	  and edges specified in the file.
	- The vertex coordinates are scaled down by a factor of 1e-3 to convert from millimeters to meters.
	
	Example:
	```
	vertices, edges, number_of_cells = read_tess_file_mm_to_m('mesh_1000.tess')
	```

	This function is tailored for files generated by Neper's tessellation tool, and may require modification 
	if the format changes.
	"""
	# Import libraries
	import numpy
	import re
	# Extract from the file name the number of cells.
	regex = re.compile(r'\d+')
	regex.findall(filename)
	list_numbers_in_filename=[int(x) for x in regex.findall(filename)]
	number_of_cells = list_numbers_in_filename[0]
	# .tess reading and extraction
	# 9 first lines are general info, number_of_cells+1 next are seeds, number_of_cells+2 next are ori, 
	# then 1 line header for vertices, 1 line number of vertices, number_of_vertices lines
	# then 1 line header for edges, 1 line number of edges, number_of_edges lines
	with open(filename, 'r') as f:
		content = f.readlines()
		# extract size of the matrices from the file
		number_of_vertices = int(content[13+2*number_of_cells])
		number_of_edges = int(content[15+2*number_of_cells+number_of_vertices])
		vertices = numpy.zeros((number_of_vertices,3))
		edges = numpy.zeros((number_of_edges,2), dtype=int)
		ii=0
		for x in content[13+2*number_of_cells+1:13+2*number_of_cells+number_of_vertices+1]:
			row = x.split()
			vertices[ii]=[1e-3*float(row[1]),1e-3*float(row[2]),1e-3*float(row[3])]
			ii+=1
		jj=0
		for x in content[15+2*number_of_cells+number_of_vertices+1:15+2*number_of_cells+number_of_vertices+number_of_edges+1]:
			row = x.split()
			edges[jj]=[int(row[1])-1,int(row[2])-1]
			jj+=1
	return vertices, edges, number_of_cells
# 
def create_merged_mesh(vertices, edges, radius, Height, Ncyl, Nsph, output_filename):
	"""
	Creates a volumetric network by generating cylinders along edges and spheres at vertices. 
	The function merges these geometric objects into a single mesh and saves it as an STL file.

	Parameters:
	- vertices (np.ndarray): A 2D numpy array of shape (N_vertices, 3), where each row represents 
	  the (x, y, z) coordinates of a vertex in 3D space.
	- edges (np.ndarray): A 2D numpy array of shape (N_edges, 2), where each row represents an 
	  edge connecting two vertices. Each entry contains the indices of the start and end vertices 
	  of the edge in the `vertices` array.
	- radius (float): The radius for both the spheres at vertices and the cylinders along edges.
	  The radius should be in the same units as the coordinates in the `vertices` array.
	- Height (float): A threshold value for the z-coordinate to determine whether spheres should 
	  be added at certain vertex locations. Spheres are added at vertices where the z-coordinate is 
	  either close to `Height` or close to 0 (ground level).
	- Ncyl (int): The number of segments used to approximate the cylinders along edges. Higher values 
	  improve the smoothness of the cylinders but increase computation time.
	- Nsph (int): The refinement order for the icosphere approximation of the spheres at vertex locations. 
	  Higher values result in more vertices in the sphere but increase computation time.
	- output_filename (str): The path and filename (including extension) to save the generated mesh in STL format.

	Returns:
	- mesh (pymesh.Mesh): A `pymesh` Mesh object containing the merged cylinders and spheres. The mesh 
	  is also saved to the specified `output_filename` in ASCII STL format.

	Notes:
	- This function assumes that the cylinders and spheres are homogeneous in radius.
	- The output file will be an ASCII-encoded STL file that can be used in 3D modeling and printing.
	"""
	# Import libraries
	import numpy 
	import pymesh
	import time
	# initialize timer
	begin_t = time.time()
	# Initialize the mesh with the first edge
	mesh  = pymesh.generate_cylinder(vertices[edges[0,0]], vertices[edges[0,1]], radius, radius, num_segments=Ncyl)
	# Compute it for all edges and merge
	count=1
	for edge in edges[1:]:
		count+=1
		print('Op√©ration ',count,'/',len(edges))
		cylinder  = pymesh.generate_cylinder(vertices[edge[0]], vertices[edge[1]], radius, radius, num_segments=Ncyl)
		mesh=pymesh.merge_meshes([mesh,cylinder])
	# Add the spheres at the vertices locations to avoid void.
	count = 0
	for i in range(len(vertices)):
		if numpy.abs(vertices[i,2] - Height) < 1e-8 or numpy.abs(vertices[i,2]) < 1e-8:
			count+=1
			print('number of added spheres:', count)
			# print('Op√©ration ',i+1,'/',len(vertices))
			sphere = pymesh.generate_icosphere(radius, vertices[i], refinement_order=Nsph)
			mesh=pymesh.merge_meshes([mesh,sphere])
	pymesh.save_mesh(output_filename, mesh, ascii=True)
	# Evaluate final time
	end_t = time.time()
	t_hours, tmin, tsec = int((end_t-begin_t)//3600), int(((end_t-begin_t)%3600)//60), int(((end_t-begin_t)%3600)%60)
	print(f"Operated in {t_hours} h {tmin} min {tsec} sec")
	return mesh
# 
def create_permeabilitty_sample_(vertices, edges, radius, Height, rad_i_tube, rad_e_tube, Length_tube, Diameter, Diameter_connector_e, Diameter_connector_i, Length_connector,chamber_height,chamber_width, Ncyl, Nsph, output_filename):
	"""
	Creates a volumetric network based on a Constructive Solid Geometry (CSG) tree, combining spheres at the vertices and cylinders along the edges. The network also includes additional geometries such as tubes and chambers using boolean operations to define the permeability sample. The final result is saved as an STL file.

	The function utilizes boolean operations to union and subtract meshes (spheres, cylinders, and tubes) in a CSG tree, which is a powerful method for building complex shapes from simpler ones.

	More information on CSG boolean operations can be found at:
	https://pymesh.readthedocs.io/en/latest/mesh_boolean.html

	Parameters:
	- vertices (np.ndarray): A 2D numpy array of shape (N_vertices, 3) containing the (x, y, z) coordinates of the vertices.
	- edges (np.ndarray): A 2D numpy array of shape (N_edges, 2) representing the edges of the mesh, with each row containing indices (0-based) referring to the two vertices that define each edge.
	- radius (float): The radius of both the spheres and cylinders used to define the network. Assumed to have consistent units across all components.
	- Height (float): The height of the sample, typically corresponding to the z-dimension in the mesh.
	- rad_i_tube (float): The internal radius of the tube.
	- rad_e_tube (float): The external radius of the tube.
	- Length_tube (float): The length of the tube along the z-axis.
	- Diameter (float): The diameter of the chamber's external cylinder.
	- Diameter_connector_e (float): The external diameter of the connector.
	- Diameter_connector_i (float): The internal diameter of the connector.
	- Length_connector (float): The length of the connector.
	- chamber_height (float): The height of the chamber (along the z-axis).
	- chamber_width (float): The width of the chamber (along the x and y axes).
	- Ncyl (int): The number of segments used to approximate the cylinders.
	- Nsph (int): The refinement order for generating the spheres (higher value gives more refined spheres).
	- output_filename (str): The path to the output file where the generated mesh will be saved in STL format.

	Returns:
	- mesh (pymesh.Mesh): The resulting mesh after applying the boolean operations, including the spheres, cylinders, tubes, and chambers.

	Outputs:
	- The function saves the final mesh to an STL file specified by `output_filename`.

	Process:
	1. The function begins by creating cylinders along the edges of the mesh and spheres at the vertices to form the initial volumetric network.
	2. It then adds additional geometries, including external and internal tubes, chambers, and connectors.
	3. Boolean operations (union and difference) are applied to combine and subtract the various meshes into the final network structure.
	4. The resulting mesh is saved to an STL file.

	Notes:
	- The function uses the `pymesh` library, which must be installed for the function to work.
	- The `CSGTree` structure allows for easy manipulation of meshes through boolean operations such as union and difference.

	Example:
	```python
	create_permeabilitty_sample_(vertices, edges, radius=0.5, Height=10, rad_i_tube=0.2, rad_e_tube=0.3, 
								 Length_tube=5, Diameter=2, Diameter_connector_e=0.5, Diameter_connector_i=0.3, 
								 Length_connector=1, chamber_height=1, chamber_width=0.5, Ncyl=12, Nsph=3, 
								 output_filename="output_mesh.stl")
	```

	This function is intended for creating complex volumetric network models used in permeability studies or other similar applications.
	"""
	# Import libraries
	import numpy 
	import pymesh
	import time
	# initialize timer
	begin_t = time.time()
	count=1
	# create list for boolean union
	list_union = []
	for edge in edges:
		count+=1
		print('Op√©ration ',count,'/',len(edges))
		cylinder  = pymesh.generate_cylinder(vertices[edge[0]], vertices[edge[1]], radius, radius, num_segments=Ncyl)
		list_union.append({"mesh": cylinder})
	# Add the spheres at the vertices locations to avoid void.
	count = 0
	for i in range(len(vertices)):
		if numpy.abs(vertices[i,2] - Height) < 1e-8 or numpy.abs(vertices[i,2]) < 1e-8:
			count+=1
			print('number of added spheres:', count)
			# print('Op√©ration ',i+1,'/',len(vertices))
			sphere = pymesh.generate_icosphere(radius, vertices[i], refinement_order=Nsph)
			list_union.append({"mesh": sphere})
	# Insert tube: 
	external_cylinder  = pymesh.generate_cylinder([Diameter/2,Diameter/2,0], [Diameter/2,Diameter/2,Height], rad_e_tube, rad_e_tube, num_segments=2*Ncyl)
	# Create the chamber
	ch_par = 0.9
	internal_cylinder_2  = pymesh.generate_cylinder([Diameter/2,Diameter/2,-chamber_height], [Diameter/2,Diameter/2,Height+chamber_height], ch_par*Diameter/2, ch_par*Diameter/2, num_segments=2*Ncyl)
	external_cylinder_2  = pymesh.generate_cylinder([Diameter/2,Diameter/2,-chamber_height], [Diameter/2,Diameter/2,Height+chamber_height], Diameter/2+chamber_width, Diameter/2+chamber_width, num_segments=2*Ncyl)
	# 
	print("Create the CSG tree")
	csg = pymesh.CSGTree({
		"union": [
		{"difference": [{ "union": list_union},{"mesh": external_cylinder}]},
		{"mesh": external_cylinder},
		{"difference": [{"mesh": external_cylinder_2},{"mesh": internal_cylinder_2}]},
		]
		})
	print("Begin boolean operation")
	mesh = csg.mesh
	print("End boolean operation")
	pymesh.save_mesh(output_filename, mesh, ascii=True)
	# Evaluate final time
	end_t = time.time()
	t_hours, tmin, tsec = int((end_t-begin_t)//3600), int(((end_t-begin_t)%3600)//60), int(((end_t-begin_t)%3600)%60)
	print(f"Operated in {t_hours} h {tmin} min {tsec} sec")
	return mesh
# 
def create_permeabilitty_sample_NoIntCyl(vertices, edges, radius, Height, rad_i_tube, rad_e_tube, Length_tube, Diameter, Diameter_connector_e, Diameter_connector_i, Length_connector,chamber_height,chamber_width, Ncyl, Nsph, output_filename):
	"""
	Creates a volumetric network using boolean operations on a Constructive Solid Geometry (CSG) tree. 
	The function generates spheres at the vertex positions and cylinders along the edges. Additionally, it constructs a chamber using external and internal cylinders but excludes the internal tube (i.e., the tube inside the chamber is not created).

	More information on CSG boolean operations can be found here:
	https://pymesh.readthedocs.io/en/latest/mesh_boolean.html

	Parameters:
	- vertices (np.ndarray): A 2D numpy array of shape (N_vertices, 3) where each row represents a vertex with (x, y, z) coordinates.
	- edges (np.ndarray): A 2D numpy array of shape (N_edges, 2) where each row represents an edge by referring to the indices (0-based) of the two vertices that form it.
	- radius (float): The radius of both the spheres and cylinders. All shapes are assumed to use this uniform radius.
	- Height (float): The height of the sample, typically corresponding to the z-dimension in the mesh.
	- rad_i_tube (float): The internal radius of the tube (not used in this version as no internal tube is generated).
	- rad_e_tube (float): The external radius of the tube.
	- Length_tube (float): The length of the tube along the z-axis (not used here).
	- Diameter (float): The diameter of the external chamber's cylinder.
	- Diameter_connector_e (float): The external diameter of the connector (not used in this version).
	- Diameter_connector_i (float): The internal diameter of the connector (not used in this version).
	- Length_connector (float): The length of the connector (not used in this version).
	- chamber_height (float): The height of the chamber along the z-axis.
	- chamber_width (float): The width of the chamber along the x and y axes.
	- Ncyl (int): The number of segments to approximate the cylinders. A higher value will result in a more refined cylinder.
	- Nsph (int): The refinement order for the spheres. Higher values yield more detailed spheres.
	- output_filename (str): The path to the output file where the resulting mesh will be saved in STL format.

	Returns:
	- mesh (pymesh.Mesh): The resulting mesh after applying the boolean operations, which includes spheres, cylinders, and the chamber geometry.

	Outputs:
	- Saves the generated mesh to an STL file at the location specified by `output_filename`.

	Process:
	1. The function first creates cylinders along the edges of the mesh and spheres at the vertices.
	2. Then, it constructs a chamber with external and internal cylinders, while excluding the internal tube (no tube is created inside the chamber).
	3. The function applies a series of union and difference boolean operations to combine the meshes, resulting in the final network structure.
	4. The final mesh is saved as an STL file.

	Notes:
	- The `pymesh` library is required for this function to work. Ensure that it is installed in your environment.
	- This function generates the chamber but does not include the internal tube that would typically form the interior structure of the chamber.
	- Boolean operations are performed using a CSG tree, which allows combining and subtracting meshes to form complex geometries.

	Example:
	```python
	create_permeabilitty_sample_NoIntCyl(vertices, edges, radius=0.5, Height=10, rad_i_tube=0.2, rad_e_tube=0.3, 
										Length_tube=5, Diameter=2, Diameter_connector_e=0.5, Diameter_connector_i=0.3, 
										Length_connector=1, chamber_height=1, chamber_width=0.5, Ncyl=12, Nsph=3, 
										output_filename="output_mesh.stl")
	```

	This function is ideal for generating permeability network models or similar volumetric network structures where internal tubes are not required.

	"""
	# Import libraries
	import numpy 
	import pymesh
	import time
	# initialize timer
	begin_t = time.time()
	count=1
	# create list for boolean union
	list_union = []
	for edge in edges:
		count+=1
		print('Op√©ration ',count,'/',len(edges))
		cylinder  = pymesh.generate_cylinder(vertices[edge[0]], vertices[edge[1]], radius, radius, num_segments=Ncyl)
		list_union.append({"mesh": cylinder})
	# Add the spheres at the vertices locations to avoid void.
	count = 0
	for i in range(len(vertices)):
		if numpy.abs(vertices[i,2] - Height) < 1e-8 or numpy.abs(vertices[i,2]) < 1e-8:
			count+=1
			print('number of added spheres:', count)
			# print('Op√©ration ',i+1,'/',len(vertices))
			sphere = pymesh.generate_icosphere(radius, vertices[i], refinement_order=Nsph)
			list_union.append({"mesh": sphere})
	# Insert tube: 
	#external_cylinder  = pymesh.generate_cylinder([Diameter/2,Diameter/2,0], [Diameter/2,Diameter/2,Height], rad_e_tube, rad_e_tube, num_segments=2*Ncyl)
	# Create the chamber
	ch_par = 0.9
	internal_cylinder_2  = pymesh.generate_cylinder([Diameter/2,Diameter/2,-chamber_height], [Diameter/2,Diameter/2,Height+chamber_height], ch_par*Diameter/2, ch_par*Diameter/2, num_segments=2*Ncyl)
	external_cylinder_2  = pymesh.generate_cylinder([Diameter/2,Diameter/2,-chamber_height], [Diameter/2,Diameter/2,Height+chamber_height], Diameter/2+chamber_width, Diameter/2+chamber_width, num_segments=2*Ncyl)
	# 
	print("Create the CSG tree")
	csg = pymesh.CSGTree({
		"union": [
		{ "union": list_union},
		{"difference": [{"mesh": external_cylinder_2},{"mesh": internal_cylinder_2}]},
		]
		})
	print("Begin boolean operation")
	mesh = csg.mesh
	print("End boolean operation")
	pymesh.save_mesh(output_filename, mesh, ascii=True)
	# Evaluate final time
	end_t = time.time()
	t_hours, tmin, tsec = int((end_t-begin_t)//3600), int(((end_t-begin_t)%3600)//60), int(((end_t-begin_t)%3600)%60)
	print(f"Operated in {t_hours} h {tmin} min {tsec} sec")
	return mesh
# 
def create_permeabilitty_sample_NoIntCyl_OnlySample(vertices, edges, radius, Height, rad_i_tube, rad_e_tube, Length_tube, Diameter, Diameter_connector_e, Diameter_connector_i, Length_connector,chamber_height,chamber_width, Ncyl, Nsph, output_filename):
	"""
	Creates a volumetric network model by performing boolean operations on a Constructive Solid Geometry (CSG) tree.
	The model consists of spheres at the vertices and cylinders along the edges, forming a network structure. 
	This version does not include the chamber or any internal tube; it generates only the sample based on the provided vertices and edges.

	More information on CSG boolean operations can be found here:
	https://pymesh.readthedocs.io/en/latest/mesh_boolean.html

	Parameters:
	- vertices (np.ndarray): A 2D numpy array of shape (N_vertices, 3), where each row contains the (x, y, z) coordinates of a vertex in the mesh.
	- edges (np.ndarray): A 2D numpy array of shape (N_edges, 2), where each row represents an edge defined by two vertices' indices.
	- radius (float): The radius of both the spheres and cylinders used to model the network. This value is homogeneous for both shapes.
	- Height (float): The height of the sample, generally along the z-axis of the mesh.
	- rad_i_tube (float): The internal radius of the tube (not used in this function version).
	- rad_e_tube (float): The external radius of the tube (not used in this function version).
	- Length_tube (float): The length of the tube along the z-axis (not used in this function version).
	- Diameter (float): The diameter of the network's external chamber (not used in this function version).
	- Diameter_connector_e (float): The external diameter of connectors (not used in this function version).
	- Diameter_connector_i (float): The internal diameter of connectors (not used in this function version).
	- Length_connector (float): The length of connectors (not used in this function version).
	- chamber_height (float): The height of the chamber (not used in this function version).
	- chamber_width (float): The width of the chamber (not used in this function version).
	- Ncyl (int): The number of segments used to approximate each cylinder. A higher number results in a more refined representation.
	- Nsph (int): The refinement order for the spheres. Higher values yield more detailed spheres.
	- output_filename (str): The output file name (including path) where the resulting 3D model will be saved in STL format.

	Returns:
	- mesh (pymesh.Mesh): The resulting mesh object after performing the boolean operations.

	Outputs:
	- Saves the generated mesh as an STL file to the location specified by `output_filename`.

	Process:
	1. The function first creates cylinders for each edge defined in the `edges` array.
	2. Spheres are then placed at each vertex location to ensure there are no voids in the network structure.
	3. The generated cylinders and spheres are combined using boolean union operations to form the volumetric network.
	4. The final mesh is saved in STL format.

	Notes:
	- This function creates the sample without including the chamber or any internal tubes (e.g., the internal structure that could be modeled inside the chamber).
	- This function is designed specifically to create only the network of spheres and cylinders based on the provided vertices and edges.
	- The `pymesh` library is required for mesh generation and boolean operations. Make sure it is installed before using this function.

	Example:
	```python
	create_permeabilitty_sample_NoIntCyl_OnlySample(vertices, edges, radius=0.5, Height=10, rad_i_tube=0.2, rad_e_tube=0.3, 
												  Length_tube=5, Diameter=2, Diameter_connector_e=0.5, Diameter_connector_i=0.3, 
												  Length_connector=1, chamber_height=1, chamber_width=0.5, Ncyl=12, Nsph=3, 
												  output_filename="output_network.stl")
	```

	The generated mesh can be used for simulations or as part of a larger modeling task involving volumetric networks.
	"""
	# Import libraries
	import numpy 
	import pymesh
	import time
	# initialize timer
	begin_t = time.time()
	count=1
	# create list for boolean union
	list_union = []
	for edge in edges:
		count+=1
		print('Op√©ration ',count,'/',len(edges))
		cylinder  = pymesh.generate_cylinder(vertices[edge[0]], vertices[edge[1]], radius, radius, num_segments=Ncyl)
		list_union.append({"mesh": cylinder})
	# Add the spheres at the vertices locations to avoid void.
	count = 0
	for i in range(len(vertices)):
		if numpy.abs(vertices[i,2] - Height) < 1e-8 or numpy.abs(vertices[i,2]) < 1e-8:
			count+=1
			print('number of added spheres:', count)
			# print('Op√©ration ',i+1,'/',len(vertices))
			sphere = pymesh.generate_icosphere(radius, vertices[i], refinement_order=Nsph)
			list_union.append({"mesh": sphere}) 
	print("Create the CSG tree")
	csg = pymesh.CSGTree({"union": list_union})
	print("Begin boolean operation")
	mesh = csg.mesh
	print("End boolean operation")
	pymesh.save_mesh(output_filename, mesh, ascii=True)
	# Evaluate final time
	end_t = time.time()
	t_hours, tmin, tsec = int((end_t-begin_t)//3600), int(((end_t-begin_t)%3600)//60), int(((end_t-begin_t)%3600)%60)
	print(f"Operated in {t_hours} h {tmin} min {tsec} sec")
	return mesh
# 
def create_only_sample(vertices, edges, radius, Height, rad_i_tube, rad_e_tube, Length_tube, Diameter, Diameter_connector_e, Diameter_connector_i, Length_connector,chamber_height,chamber_width, Ncyl, Nsph, output_filename):
	"""
	Creates a volumetric network by performing boolean operations on a Constructive Solid Geometry (CSG) tree.
	The network is formed by spheres at the vertices and cylinders along the edges, with the option to add an external tube surrounding the structure.

	The function uses the `pymesh` library to generate the geometry and boolean operations.

	For more information on CSG operations, see: https://pymesh.readthedocs.io/en/latest/mesh_boolean.html

	Parameters:
	- vertices (np.ndarray): A 2D numpy array of shape (N_vertices, 3), where each row contains the (x, y, z) coordinates of a vertex.
	- edges (np.ndarray): A 2D numpy array of shape (N_edges, 2), where each row defines an edge between two vertices by their indices.
	- radius (float): The radius of both the cylinders and the spheres used in the network. It is assumed to be the same for both shapes.
	- Height (float): The height of the sample (along the z-axis of the mesh).
	- rad_i_tube (float): Internal radius of the tube (not used in this function version).
	- rad_e_tube (float): External radius of the tube surrounding the structure.
	- Length_tube (float): Length of the tube (not used in this function version).
	- Diameter (float): The diameter of the external chamber (not used in this function version).
	- Diameter_connector_e (float): External diameter of connectors (not used in this function version).
	- Diameter_connector_i (float): Internal diameter of connectors (not used in this function version).
	- Length_connector (float): Length of connectors (not used in this function version).
	- chamber_height (float): Height of the chamber (not used in this function version).
	- chamber_width (float): Width of the chamber (not used in this function version).
	- Ncyl (int): The number of segments used to approximate each cylinder. A higher number provides a more refined representation.
	- Nsph (int): The refinement order for the spheres. Higher values result in more detailed spheres.
	- output_filename (str): The file path where the generated 3D model will be saved in STL format.

	Returns:
	- mesh (pymesh.Mesh): The resulting mesh object after boolean operations have been applied.

	Outputs:
	- The mesh is saved as an STL file at the location specified by `output_filename`.

	Process:
	1. The function creates cylinders for each edge defined in the `edges` array.
	2. Spheres are placed at each vertex to ensure the network is continuous and avoids voids.
	3. An external tube is created around the structure based on the provided `rad_e_tube`.
	4. The cylinders, spheres, and external tube are combined using boolean operations into a single mesh.
	5. The final mesh is saved in STL format.

	Example:
	```python
	create_only_sample(vertices, edges, radius=0.5, Height=10, rad_i_tube=0.2, rad_e_tube=0.3, 
						Length_tube=5, Diameter=2, Diameter_connector_e=0.5, Diameter_connector_i=0.3, 
						Length_connector=1, chamber_height=1, chamber_width=0.5, Ncyl=12, Nsph=3, 
						output_filename="network_sample.stl")
	```

	Notes:
	- This function is designed to generate only the network structure (vertices and edges) along with an optional external tube.
	- The chamber and internal structures are not included in this version of the function.
	- Make sure the `pymesh` library is installed and available before using this function.

	Execution time is also printed, providing feedback on how long the function takes to complete the operations.
	"""
	# Import libraries
	import numpy 
	import pymesh
	import time
	# initialize timer
	begin_t = time.time()
	count=1
	# create list for boolean union
	list_union = []
	for edge in edges:
		count+=1
		print('Op√©ration ',count,'/',len(edges))
		cylinder  = pymesh.generate_cylinder(vertices[edge[0]], vertices[edge[1]], radius, radius, num_segments=Ncyl)
		list_union.append({"mesh": cylinder})
	# Add the spheres at the vertices locations to avoid void.
	count = 0
	for i in range(len(vertices)):
		if numpy.abs(vertices[i,2] - Height) < 1e-8 or numpy.abs(vertices[i,2]) < 1e-8:
			count+=1
			print('number of added spheres:', count)
			# print('Op√©ration ',i+1,'/',len(vertices))
			sphere = pymesh.generate_icosphere(radius, vertices[i], refinement_order=Nsph)
			list_union.append({"mesh": sphere})
	# Insert tube: 
	external_cylinder  = pymesh.generate_cylinder([Diameter/2,Diameter/2,0], [Diameter/2,Diameter/2,Height], rad_e_tube, rad_e_tube, num_segments=2*Ncyl) 
	print("Create the CSG tree")
	csg = pymesh.CSGTree({
		"union": [
		{"difference": [{ "union": list_union},{"mesh": external_cylinder}]},
		{"mesh": external_cylinder},
		]
		})
	print("Begin boolean operation")
	mesh = csg.mesh
	print("End boolean operation")
	pymesh.save_mesh(output_filename, mesh, ascii=True)
	# Evaluate final time
	end_t = time.time()
	t_hours, tmin, tsec = int((end_t-begin_t)//3600), int(((end_t-begin_t)%3600)//60), int(((end_t-begin_t)%3600)%60)
	print(f"Operated in {t_hours} h {tmin} min {tsec} sec")
	return mesh
# EoF