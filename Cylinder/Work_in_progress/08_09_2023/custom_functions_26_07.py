# Created by Thomas Lavigne
# 22/03/2023
# 
def print_info_versions():
	print("""The version of Neper used is:
		
========================    N   e   p   e   r    =======================
Info   : A software package for polycrystal generation and meshing.
Info   : Version 4.5.1-4
Info   : Built with: gsl|muparser|opengjk|openmp|nlopt|libscotch (full)
Info   : Running on 8 threads.
Info   : <https://neper.info>
Info   : Copyright (C) 2003-2022, and GNU GPL'd, by Romain Quey.
========================================================================

The python3 environment is used. Pymesh can be run within a docker environment:

docker run -ti -v $(pwd):/home/pymesh/shared -w /home/pymesh/shared pymesh/pymesh bash
	""")
	pass
# 
def read_tess_file(filename):
	"""
	Given a filename, the number of cells is identified.
	This functions extracts from the .tess file generated by neper the vertices and edges and return them in two lists.

	Inputs: 
	- number_of_cells: integer
	Outputs:
	- vertices: np.array of all the vertices (N_vertices,3)
	- edges: np.array of all the edges (N_edges,2)
	"""
	# Import libraries
	import numpy
	import re
	# Extract from the file name the number of cells.
	regex = re.compile(r'\d+')
	regex.findall(filename)
	list_numbers_in_filename=[int(x) for x in regex.findall(filename)]
	number_of_cells = list_numbers_in_filename[0]
	# .tess reading and extraction
	# 9 first lines are general info, number_of_cells+1 next are seeds, number_of_cells+2 next are ori, 
	# then 1 line header for vertices, 1 line number of vertices, number_of_vertices lines
	# then 1 line header for edges, 1 line number of edges, number_of_edges lines
	with open(filename, 'r') as f:
		content = f.readlines()
		# extract size of the matrices from the file
		number_of_vertices = int(content[13+2*number_of_cells])
		number_of_edges = int(content[15+2*number_of_cells+number_of_vertices])
		vertices = numpy.zeros((number_of_vertices,3))
		edges = numpy.zeros((number_of_edges,2), dtype=int)
		ii=0
		for x in content[13+2*number_of_cells+1:13+2*number_of_cells+number_of_vertices+1]:
			row = x.split()
			vertices[ii]=[float(row[1]),float(row[2]),float(row[3])]
			ii+=1
		jj=0
		for x in content[15+2*number_of_cells+number_of_vertices+1:15+2*number_of_cells+number_of_vertices+number_of_edges+1]:
			row = x.split()
			edges[jj]=[int(row[1])-1,int(row[2])-1]
			jj+=1
	return vertices, edges, number_of_cells
# 
def read_tess_file_mm_to_m(filename):
	"""
	Given a filename, the number of cells is identified.
	This functions extracts from the .tess file generated by neper the vertices and edges and return them in two lists.

	Inputs: 
	- number_of_cells: integer
	Outputs:
	- vertices: np.array of all the vertices (N_vertices,3)
	- edges: np.array of all the edges (N_edges,2)
	"""
	# Import libraries
	import numpy
	import re
	# Extract from the file name the number of cells.
	regex = re.compile(r'\d+')
	regex.findall(filename)
	list_numbers_in_filename=[int(x) for x in regex.findall(filename)]
	number_of_cells = list_numbers_in_filename[0]
	# .tess reading and extraction
	# 9 first lines are general info, number_of_cells+1 next are seeds, number_of_cells+2 next are ori, 
	# then 1 line header for vertices, 1 line number of vertices, number_of_vertices lines
	# then 1 line header for edges, 1 line number of edges, number_of_edges lines
	with open(filename, 'r') as f:
		content = f.readlines()
		# extract size of the matrices from the file
		number_of_vertices = int(content[13+2*number_of_cells])
		number_of_edges = int(content[15+2*number_of_cells+number_of_vertices])
		vertices = numpy.zeros((number_of_vertices,3))
		edges = numpy.zeros((number_of_edges,2), dtype=int)
		ii=0
		for x in content[13+2*number_of_cells+1:13+2*number_of_cells+number_of_vertices+1]:
			row = x.split()
			vertices[ii]=[1e-3*float(row[1]),1e-3*float(row[2]),1e-3*float(row[3])]
			ii+=1
		jj=0
		for x in content[15+2*number_of_cells+number_of_vertices+1:15+2*number_of_cells+number_of_vertices+number_of_edges+1]:
			row = x.split()
			edges[jj]=[int(row[1])-1,int(row[2])-1]
			jj+=1
	return vertices, edges, number_of_cells
# 
def create_merged_mesh(vertices, edges, radius, Height, Ncyl, Nsph, output_filename):
	"""
	Given a table of vertices and the corresponding edges, this functions creates a volumic network by merging spheres at the vertices positions and cylinders along the edges.

	Inputs:
	- vertices: np.array (N_vertices,3)
	- edges: np.array (N_edges,2)
	- radius: radius of the cylinder and spheres. Homogeneous for now. Must have same unit as the mesh.
	- output_filename: string

	Outputs:
	- None, write a stl file.
	"""
	# Import libraries
	import numpy 
	import pymesh
	import time
	# initialize timer
	begin_t = time.time()
	# Initialize the mesh with the first edge
	mesh  = pymesh.generate_cylinder(vertices[edges[0,0]], vertices[edges[0,1]], radius, radius, num_segments=Ncyl)
	# Compute it for all edges and merge
	count=1
	for edge in edges[1:]:
		count+=1
		print('Opération ',count,'/',len(edges))
		cylinder  = pymesh.generate_cylinder(vertices[edge[0]], vertices[edge[1]], radius, radius, num_segments=Ncyl)
		mesh=pymesh.merge_meshes([mesh,cylinder])
	# Add the spheres at the vertices locations to avoid void.
	count = 0
	for i in range(len(vertices)):
		if numpy.abs(vertices[i,2] - Height) < 1e-8 or numpy.abs(vertices[i,2]) < 1e-8:
			count+=1
			print('number of added spheres:', count)
			# print('Opération ',i+1,'/',len(vertices))
			sphere = pymesh.generate_icosphere(radius, vertices[i], refinement_order=Nsph)
			mesh=pymesh.merge_meshes([mesh,sphere])
	pymesh.save_mesh(output_filename, mesh, ascii=True)
	# Evaluate final time
	end_t = time.time()
	t_hours, tmin, tsec = int((end_t-begin_t)//3600), int(((end_t-begin_t)%3600)//60), int(((end_t-begin_t)%3600)%60)
	print(f"Operated in {t_hours} h {tmin} min {tsec} sec")
	return mesh

def create_permeabilitty_sample_ANAS(vertices, edges, radius, Height, rad_i_tube, rad_e_tube, Length_tube, Diameter, Diameter_connector_e, Diameter_connector_i, Length_connector,chamber_height,chamber_width, Ncyl, Nsph, output_filename):
	"""
	Given a table of vertices and the corresponding edges, this functions creates a volumic network by creating boolean operations on a Constructive Solid Geometry tree (CSG)
	with spheres at the vertices positions and cylinders along the edges.
	https://pymesh.readthedocs.io/en/latest/mesh_boolean.html
	Inputs:
	- vertices: np.array (N_vertices,3)
	- edges: np.array (N_edges,2)
	- radius: radius of the cylinder and spheres. Homogeneous for now. Must have same unit as the mesh.
	- output_filename: string

	Outputs:
	- None, write a stl file.
	"""
	# Import libraries
	import numpy 
	import pymesh
	import time
	# initialize timer
	begin_t = time.time()
	count=1
	# create list for boolean union
	list_union = []
	for edge in edges:
		count+=1
		print('Opération ',count,'/',len(edges))
		cylinder  = pymesh.generate_cylinder(vertices[edge[0]], vertices[edge[1]], radius, radius, num_segments=Ncyl)
		list_union.append({"mesh": cylinder})
	# Add the spheres at the vertices locations to avoid void.
	count = 0
	for i in range(len(vertices)):
		if numpy.abs(vertices[i,2] - Height) < 1e-8 or numpy.abs(vertices[i,2]) < 1e-8:
			count+=1
			print('number of added spheres:', count)
			# print('Opération ',i+1,'/',len(vertices))
			sphere = pymesh.generate_icosphere(radius, vertices[i], refinement_order=Nsph)
			list_union.append({"mesh": sphere})
	# Insert tube: 
	external_cylinder  = pymesh.generate_cylinder([Diameter/2,Diameter/2,0], [Diameter/2,Diameter/2,Height], rad_e_tube, rad_e_tube, num_segments=2*Ncyl)
	# Create the chamber
	ch_par = 0.9
	internal_cylinder_2  = pymesh.generate_cylinder([Diameter/2,Diameter/2,-chamber_height], [Diameter/2,Diameter/2,Height+chamber_height], ch_par*Diameter/2, ch_par*Diameter/2, num_segments=2*Ncyl)
	external_cylinder_2  = pymesh.generate_cylinder([Diameter/2,Diameter/2,-chamber_height], [Diameter/2,Diameter/2,Height+chamber_height], Diameter/2+chamber_width, Diameter/2+chamber_width, num_segments=2*Ncyl)
	# 
	print("Create the CSG tree")
	csg = pymesh.CSGTree({
		"union": [
		{"difference": [{ "union": list_union},{"mesh": external_cylinder}]},
		{"mesh": external_cylinder},
		{"difference": [{"mesh": external_cylinder_2},{"mesh": internal_cylinder_2}]},
		]
		})
	print("Begin boolean operation")
	mesh = csg.mesh
	print("End boolean operation")
	pymesh.save_mesh(output_filename, mesh, ascii=True)
	# Evaluate final time
	end_t = time.time()
	t_hours, tmin, tsec = int((end_t-begin_t)//3600), int(((end_t-begin_t)%3600)//60), int(((end_t-begin_t)%3600)%60)
	print(f"Operated in {t_hours} h {tmin} min {tsec} sec")
	return mesh